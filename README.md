# Entropy-Aware Collaborative Kanban

A high-entropy task management system that simulates real-world project drift through algorithmic task decay, data corruption, and intelligent conflict resolution. The Entropy-Aware Kanban introduces **temporal decay mechanics** where tasks naturally degrade if left unattended, simulating the chaos of real-world project management.


---

## The Drift Algorithm

### Implementation

```js
function calculatePriorityScore(task) {
  const now = Date.now();
  const timeSinceUpdate = now - new Date(task.updated_at).getTime();
  const timeUntilDeadline = new Date(task.deadline).getTime() - now;
  
  if (timeUntilDeadline <= 0) return Infinity; // Overdue tasks
  
  return (timeSinceUpdate * task.volatility_factor) / timeUntilDeadline;
}
```

### Behaviour Over Time

**T+0 (Task Created)**

- Priority Score: ~0
- Position: Top of list
- Appearance: Normal

**T+30 seconds**

- Priority Score: ~0.00005 (for V=0.5)
- Position: Slight drift downward
- Appearance: Normal

**T+2 minutes**

- Priority Score: ~0.0002
- Position: Noticeable drift
- Appearance: Red border appears, slight skew

**T+5 minutes**

- Priority Score: ~0.0005
- Position: Near bottom
- Appearance: Strong red border, visible skew
- **If in "Doing"**: Description gets corrupted

### Why This Algorithm?

Traditional Kanban boards are static. This algorithm simulates:

- **Technical debt accumulation**: Old tasks become "harder" to fix
- **Context switching cost**: Stale tasks lose relevance
- **Urgency vs. Age trade-off**: Deadline proximity matters


---

## Edge Cases & Solutions

### 1. **WebSocket Disconnection During Task Move**

**Problem**: User moves task, WebSocket disconnects before confirmation

**Solution**:

```javascript
// Frontend maintains pendingUpdates
socket.on('disconnect', () => {
  // Don't auto rollback pending updates
  // Wait for reconnection to resolve
});

// On reconnect, server broadcasts current state
socket.on('connect', () => {
  // Merge pending updates with server state
});
```

### 2. **Corruption During User Interaction**

**Problem**: User is reading a task description, corruption fires, description changes mid-read

**Solution**:

- Corruption only affects tasks in "Doing" status
- Visual warning ( "**âš ï¸ CORRUPTED** " badge)
- User can still move task to resolve
- Description change is intentional "chaos" feature

### 3. **Rapid Button Clicking**

**Problem**: User clicks "Move â†’" several times rapidly

**Solution**:

```javascript
// pendingUpdates prevents duplicate requests
if (pendingUpdates.current.has(taskId)) {
  return; // Ignore click while update in flight
}
```

### 4. **Server Crash Mid-Update**

**Problem**: Server crashes after receiving PATCH but before broadcasting

**Solution**:

- Optimistic update already applied in UI
- On server restart, in-memory tasks reset
- WebSocket reconnect triggers full state sync
- User sees rollback (data loss warning could be added)

**Production improvement**: Add persistent storage (PostgreSQL/MongoDB)

### 5. **Two Users Move Same Task Simultaneously**

**Problem**:

- User A: Todo â†’ Doing (v0)
- User B: Todo â†’ Done (v0)
- Both sent within 10ms

**Solution**:

```
Server receives both requests:
1. First request (A): Updates task, version becomes v1
2. Second request (B): Version mismatch (expects v0, sees v1)
3. Second request returns 409 Conflict
4. User B sees notification, task shows in "Doing"
```

### 6. **Task Corruption + User Move = Race**

**Problem**: Corruption engine and user both try to update same task

**Solution**:

- Both use version checking
- Whichever hits server first wins
- Loser gets 409 and rolls back
- No data corruption possible

### 7. **Network Partition (Split Brain)**

**Problem**: Client loses connection, makes changes, reconnects

**Solution**:

- While disconnected: Connection status shows "**ðŸ”´ Disconnected** "
- Update attempts fail immediately with network error
- UI rolls back changes
- On reconnect: Server broadcasts authoritative state

### 8. **Browser Tab Sleep (Background Tab)**

**Problem**: Tab goes to sleep, wakes up after 10 minutes, state is stale

**Solution**:

```javascript
// WebSocket automatically reconnects
// Server immediately broadcasts current state
socket.on('tasks_updated', (serverTasks) => {
  // Overwrite stale local state
  setTasks(serverTasks);
});
```


---

## Why AI Would Struggle

This assessment is designed to expose gaps in code generated by an LLM:

### 1. **Understanding Temporal Complexity**

AI might generate:

```javascript
// Naive approach
tasks.sort((a, b) => a.created_at - b.created_at);
```

But misses:

- Priority score needs **three variables** (time, volatility, deadline)
- Score must **recalculate continuously**
- Sorting must happen **server-side** (not just client)

### 2. **Race Condition Awareness**

AI might generate:

```javascript
// Broken - no conflict detection
const updateTask = async (id, data) => {
  await axios.patch(`/tasks/${id}`, data);
  setTasks(updatedTasks);
};
```

But misses:

- **Optimistic updates** for UX
- **Version tracking** to detect conflicts
- **Rollback logic** when conflicts occur
- **Pending state management** to prevent duplicate requests

### 3. **State Synchronization Edge Cases**

AI might generate:

```javascript
// Broken - overwrites pending changes
socket.on('tasks_updated', (tasks) => {
  setTasks(tasks); // Oops! Lost optimistic updates
});
```

But misses:

- Need to **merge** server state with pending local changes
- Handle **partial updates** during network issues
- **Conflict resolution** when server disagrees

### 4. **Error Boundary Implementation**

AI might generate:

```javascript
// Incomplete
try {
  await updateTask();
} catch (error) {
  console.error(error);
}
```

But misses:

- **React Error Boundaries** for component crashes
- **Different handling** for 409 vs 500 vs network errors
- **User notifications** (not just console logs)
- **Graceful degradation** (app keeps working)

### 5. **Background Job Coordination**

AI might generate:

```javascript
// Broken - corrupts all tasks
setInterval(() => {
  tasks.forEach(task => {
    task.description = corrupt(task.description);
  });
}, 60000);
```

But misses:

- Only corrupt **stale** tasks (age check)
- Only corrupt **"Doing"** status
- **Random selection** (not all tasks)
- **Broadcast update** to clients

### 6. **CSS Transform Understanding**

AI might generate:

```css
/* Static - doesn't reflect priority */
.high-priority {
  transform: skewX(-5deg);
}
```

But misses:

- Transform should be **dynamic** (based on P score)
- **Gradual progression** (small skew â†’ large skew)
- **Capping** max skew (or it looks broken)

### 7. **WebSocket Lifecycle Management**

AI might generate:

```javascript
// Memory leak!
useEffect(() => {
  const socket = io(API_URL);
  socket.on('tasks_updated', setTasks);
}, []); // Missing cleanup!
```

But misses:

- **Cleanup function** to disconnect socket
- **Reconnection handling** on disconnect
- **Error event listeners** for connection failures

---
